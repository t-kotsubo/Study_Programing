# これからオブジェクト指向を学ぶ方へ送りたい旅のしおり
###### SOLID原則を知ろう
###### tags: `ぺちおぶ`
---

2018/11/18  hiro

:::info
目次
[TOC]
:::


## この記事について

本稿は行ったPHPer向けのオブジェクト指向勉強会を社内研修にて行った際のメモを編集したものです。
つきましてはサンプルコードは全てPHPにて記載されています。

### 目的
オブジェクト指向パラダイム(OOP)の入り口としてSOLID原則とその周辺知識を得る事を目的としています。
つきましては、一般的にオブジェクト指向の説明として登場する、『継承』、『カプセル化』、『ポリモーフィズム』といった**手法を中心には説明をしておりません**。
概念理解から入り、具体性を紐解いていくトップダウンスタイルでの説明を試みています。

### 対象となる方

言語の基本的な構文を理解している、もしくは
MVCフレームワーク等を使用した事がある、入門編を卒業した辺りの層をターゲットとしています。


## はじめに

冒頭からこんな事を言うのもなんですが、本稿を読了してもオブジェクト指向設計はおろかオブジェクト指向プログラミングすらできるようにはなりません。

謙遜でもなんんでもなく本当になりません。
まずは、本稿の目的する所が何なのかを先に軽く触れておきます。


例えば知らない土地に初めて旅行に行く際。
右も左もわからないまま手探りで巡るのももちろん楽しいですが、事前に旅のしおりを読み、景色の良い場所がどこか、美味しいお店はどこにああるか、などを知り、旅の途中もしおりを読みながら進んでいくとより快適な度ができるかと思います。


本稿の狙いはまさにそのしおりにあたるものです。
これから『オブジェクト指向』という漠然としていて正体が見えづらい物を学習するに前に、そもそも今から学ぶものはいったいどんなものなんだろう？という物を先にイメージしてもらう事によって、これからの学習を少しでも円滑に進めて頂ける事を期待しています。


したがって、初学時の指針となる事を目的としておりますので、筆者の主観や個人的な思想により一般論ではない事も含まれているかと思います。
なので、これから説明する『オブジェクト指向』とはオブジェクト指向の要素を全てを網羅している訳では当然ながらありません。

ただ、理解をする為の土台となるとは言えると思っています。

このしおりを持って実際にオブジェクト指向の学習という旅出るとこのしおりだけでは伝えきれなかった事も含めて様々な実体験をするでしょう。そして、その度を終えた頃にはようやく、オブジェクト指向設計やプログラミングが体感できるようになる事かと思います。

そしてその暁に、またそれぞれの新たなしおりが作成されていると非常に嬉しいです。

## 序

### 1. 決まりがあるから従うのではなく、メリットがあるから決まりがある


オブジェクト指向の学習を進めていくと様々な戦術や原則を目にする事があると思います。
ただ、それらのルールは『そう決まっているから（理由はわからないけど）そう実装する』では正しく使う事はできないでしょう。

そもそも、それらのルールはなぜ存在するのでしょうか。
おそらく何かしらの必要性があるからルールが出来たと考えるのが自然な気がします。
では、その必要性とはなんなのでしょう？

その必要性が理解できれば、逆説的に紐づくルールを正しく使う事ができるようになるかもしれません。

まずはそこから始めて行きたいと思います。


### 2. まずはトップダウンでのオブジェクト指向の有用性を理解してみよう


#### 2-1. オブジェクト指向を使うから良いシステムになるわけではない。良いシステムにする為の手法の一つとしてオブジェクト指向を使う

良いシステムとはなんだろう？
ぱっと思いつくワードを並べてみました。

- 保守性が高い
- 機能追加、改修が容易
- 読みやすい
- 環境の変更がしやすい
- バグが出た際に直しやすい


上記要件をもう少し具体的に整理してみましょう

##### 保守性が高いとは？

もちろん様々な要素がありますが、今回は以下の点に注目してみようと思います。

- 機能の依存関係が密接でない（疎結合）

なぜ依存関係が密接（密結合）だと保守性が悪い？

1. 動いているソースを修正するとバグのリスクが必ず生まれる
密結合の場合、各処理同士が密接に関係しているため、一部の変更が他の処理に影響が出る可能性がある = 不具合を生むリスクが高まります

2. 修正の際の影響範囲が大きくなる
密結合の場合、処理を修正する理由が複数になります。
例えば同じ関数内に3つの業務に関する処理が実装されている場合、その関数を修正する理由が3つある事になります。
そして、そのいずれの理由で修正を加えたとしても（本来関係ないはずの）他の理由に関する処理にも影響が生まれる事となります

つまり、システムが密結合だと、保守の際のリスクが高まる = 保守性が悪いと言えそうです。
逆の言い方をすれば、保守性が高いシステムとは疎結合である必要があると言えそうです。


##### 機能追加、改修が容易とは？

- 機能追加について
機能を追加する際の理想はどういう形でしょう？
上記保守性の説明でもあったが、既存のソースコードに手を加える度にバグを生むリスクが高まる。
であれば、機能追加する際も、既存のソースコードに手を加える必要性が極力少なく必要な機能を追加する事が出来たほう方が『機能追加が容易』と考える事ができそうです。

- 改修について
追加ではなく変更が要件となる改修の場合は嫌でも既存のソースコードに手を加える必要性が出てきそうです。
それを踏まえて『改修が容易』となる形を考えてみると、これまた保守性の話しと重なりますが、各機能の結合度（関わり合い）が低い状態であれば、改修に必要な箇所のみをピンポイントに修正する事ができ、結果として改修で既存のソースコードを修正するリスクを抑えられそうです。
ここではいったん、『改修が容易』とは『改修範囲を必要最小限で制限できる』という理解にしておいたいと思います。


##### 読みやすいとは

『読みやすい』という概念は人それぞれなので、完全な正解を導き出すは難しいです

あくまで個人的な感覚となりますが、

- ソースから処理の内容が把握しやすい
- 呼び出し（使う側）と実装が分かれている
- 一処理の単位が小さい
- モデルで表現出来ている
    - [TIPS:モデルとは](/i6DX6SRoQB-KRhMbzjb2Tw) 

『読みやすい』とは今回は以上の定義しようかと思います。

##### 環境の変更がしやすいとは？

例えばFW(フレームワーク)、DB(データベース)、API、等、はシステムが解決したい課題（例えば業務等）とは直接関係ないレイヤーです。
システムの関心事からみると、どの種類のFWを使用しているか、どの種類のDBにデータを保存しているか、といった事は使用するユーザー等からみると全く興味の無い分野です。

これらのレイヤーは（システムの関心事から見ると）重要性の低い、逆の見方をすると、変更する可能性が高くなるレイヤーとなるｔ思います。。
サーバーを移行するにあたってDBの種類を変えたい、
FWを今流行りのものに載せ替えたい、画面UIをすっきりしたい、等。
では、どのような作りになっていればそれが容易にできるでしょうか。

一つの答えとして、これらの(関心事以外の)レイヤーと核となるレイヤーがそれぞれ疎結合となっており、最低限の約束事のみに基づいて連携できる仕組みとなっていれば、その約束事を守りさえすればば自由に入れ替えができる気がします。

『環境の変更がしやすい』とは(解の一つとして)レイヤー間が疎結合となっているとしようと思います。



##### バグが出た際に直しやすい？


TBD



こうして整理してみると、一つのパワーワードが見えてきました。
そうです。『疎結合』。
この疎結合の状態を維持し、ソフトウェアの柔軟性を担保する事（変更容易性）で上記の大部分を満たせそうな気がしてきました。

そしてこの**変更容易性を実現する事がOOP(オブジェクト指向パラダイム)の最大目的**だと筆者は考えています。

## SOLID原則

### Ⅰ. それ(全部じゃないけど)解決できますよ。そう、OCPならね

**OCP(open/closed principle)**

以下 wikipedia

> かいほうへいさげんそく。open/closed principle、OCP）とは、オブジェクト指向プログラミングにおいて、クラス（およびその他のプログラム単位）は拡張に対して開いて (open) いなければならず、修正に対して閉じて (closed) いなければならないという設計上の原則である。


ちょっとわかり辛いのですが、ざっくり言うと
プログラムが拡張はできるけど(Open)修正はしないでよい(Close)ように設計すると良い
という意味です。

もっとわかりやすく言いかえれば、(機能拡張する際に)既存のソースコードに手を加える事なく追加ができるようにするという事になります。


良いソフトウェアの定義でも再三出てきましたが、既存のソースコードに手を加えるという事は必ずバグを生むリスクが発生します。
何か新機能を追加する度に常に既に動いている機能がバグる可能性を秘めていたら追加し辛いですよね。
OCPは、(極力)既存ソースには手を加えずに(ファイル、クラス、メソッド等の)追加作業だけで拡張できるようにしておきましょうというシンプルな原則です。

実装の方法というよりは概念の話しだと捉えても良いかもしれません。

#### ちなみにこいつは5人衆

オブジェクト指向設計の5原則と呼ばれるものがあります。
頭文字を取って、SOLID の原則などよばれたりします。

- Single Responsibility Principle(単一責任の原則)
- Open/closed principle(開放・閉鎖原則)
- Liskov substitution principle(リスコフの置換原則)
- Interface segregation principle(インターフェース分離原則)
- Dependency inversion principle(依存性逆転の原則)

今紹介した『OCP』はこの　SOLID 原則の一つとなります

ここからはやや個人的な独断になりますが、このOCP以外の4原則やデザインパターンと呼ばれる実装パターンの多くは、このOCP(という概念)を実現したいが為の手法だと考えても良いと考えています。

*Clean Architecture　達人に学ぶソフトウェアの構造と設計* の言葉を借りると

> ソフトウェアの振る舞いは、既存の成果物を変更せず拡張できるようにすべきである、ということだ。
これこそが、我々がソフトウェアアーキテクチャを学ぶ根本的な理由だ。

となり、


> ちょっとした拡張の為に大量の書き換えが必要となるようなら、そのソフトウェアシステムのアーキテクチャは大失敗への道を進んでいることになる。

とまで言い切ってます。


そこで、あえてSOLIDに優先順位をふるとしたら

O >= D >= S >> I > L

くらいに捉えても良いかなと考えています。(この辺は特に考え方により様々だと思います。学習が進んだ際にあなたなりの考えを探してみてください)


ではこの順番に従い、まず先程紹介したOCPについて説明したいと思います。
(OCP以外の4つは後ほど説明したいと思います)

#### それはそうかも知れないが、実際どーゆーこと？

確かに既に動いている処理に修正を加えなければ、既存処理は守られそうです。
理屈はわかりました。

ただ、この言葉だけでは具体的には何をどうする事なのでしょう？
もちろん言葉を知っただけでは意味がないので、そろそろ具体的なソースを見ながら確認して行きましょう。


ここでは『架空の送金システムで送信先の銀行を増やせるようにしたい』
という例で説明したいと思います。

:::info
ちなみに本稿での例の大半は日本語でクラス名メソッド名を定義してます。
視覚的なわかりやすさや、命名を考える時間も短縮できておすすめです！
:::

とりあえず金額オブジェクトを受けって送金できる送金銀行クラスを用意してみました。

```php
<?php
// 金額クラス
final class 金額
{
    private $金額;
    
    public function __construct(int $金額)
    {
        $this->金額 = $金額;
    }
}
// 送金先銀行クラス1
final class みずほ銀行 {
    public function 送金(金額 $金額) {
        // みずほ用送金処理
    }
}

// 送金先銀行クラス2
final class SMBC銀行 {
    public function 送金(金額 $金額) {
        // SMBC用送金処理
    }
}
```

では、実際に二つのクラスを使用して送金してみましょう。

```php
<?php

// 送金処理関数
function 送金処理(string $送金先銀行名, int $送金額): void
{
    if ($送金先銀行名 === 'みずほ') {
       $送金先銀行 = new みずほ銀行();
    } elseif ($送金先銀行名 === 'SMBC') {
       $送金先銀行 = new SMBC銀行();
    } else {
        throw new RuntimeException('送金先銀行がありません');
    }

    $送金結果 = $送金先銀行->送金(new 金額($送金額));
    
    if ($送金結果) {
        // 成功したときの処理
    } else {
        // 失敗したときの処理
    }
}


// 実際に送金処理を呼ぶコード
送金処理('みずほ', 1000);
```

処理としては問題なさそうに見えます。
`Class` も使用しているしけっこうオブジェクト指向設計っぽいプログラミングになったのではないでしょうか。

...
...
...

実はこのコードは問題だらけです。

例えば、送金先にりそな銀行を追加したくなった場合を考えてみましょう。


まずはりそな銀行用の銀行クラスを作成します
```php
<?php
// 送金先銀行クラス3
final class SMBC銀行 {
    public function 送金() {
        // SMBC用送金処理
    }
}
```

このクラスからも送金できるように、送金処理関数に修正を加えましょう。

```php
<?php

// 送金処理関数
function 送金処理(string $送金先銀行名, int $送金額): void
{
    if ($送金先銀行名 === 'みずほ') {
       $送金先銀行 = new みずほ銀行();
    } elseif ($送金先銀行名 === 'SMBC') {
       $送金先銀行 = new SMBC銀行();
    } elseif ($送金先銀行名 === 'りそな') {  // りそな銀行に遅れるように判断を追加
       $送金先銀行 = new りそな銀行();        // 実際のりそな銀行オブジェクト生成処理を追加
    } else {
        throw new RuntimeException('送金先銀行がありません');
    }

    $送金結果 = $送金先銀行->送金(new 金額($送金額));
    
    if ($送金結果) {
        // 成功したときの処理
    } else {
        // 失敗したときの処理
    }
}

// クライアントコード
送金処理('りそな', 1000);
```

りそな銀行にも送金できるように拡張はできました。
ただ、既存のソースコードの修正をしています。
つまり、OCPの原則からははずれてしまっているようです。
修正を加えた以上、この処理は全て影響を受ける事になりますので、再テストが必要となるでしょう

では、OCPの原則を適用できるようにはどうしたら良いでしょうか？
今回上記の例で問題となってのは『送金処理関数を修正しないと送金先を追加できない』という事でした。
つまり送金処理関数のロジックが良くないのです。

もう少し具体的に言うと、送金処理関数の中で各送金銀行オブジェクトを作成している事が問題です。このままではどうやっても新規送信先を追加する度に修正しなくてはいけません。


ここで登場するのが `interface` です。

先程のコードを`interface`を使用した形に修正してみようと思います。

```php
<?php
// 送金先銀行共通の振る舞いを定義したinterfaceを作成
interface 送金先銀行
{
    public function 送金(金額 $金額): 送金結果;
}
// 送金先銀行クラスは上のinterfaceを使用して作成する
final class みずほ銀行 implements 送金先銀行
{
    public function 送金(金額 $金額): 送金結果 
    {
        // 具体的な送金処理
    }
}

final class りそな銀行 implements 送金先銀行
{
    public function 送金(金額 $金額): 送金結果 
    {
        // 具体的な送金処理
    }
}

function 送金処理(送金銀行 $送金先銀行, int $送金額): void
{
    $送金結果 = $送金先銀行->送金(new 金額($送金額));

    if ($送金結果->成功したか()) {
        // 成功したときの処理
    } else {
        // 失敗したときの処理
        $送金パラメタ->通知()->通知する($送金結果->失敗理由());
    }
}

// クライアントコード
// みずほ銀行に送る処理
送金処理(new みずほ銀行クラス, 1000);
// りそな銀行に送る処理
送金処理(new りそな銀行クラス, 1000);
```

なんかすっきりしました。
さっそく詳しく見ていきましょう。


まずはメインの送金処理関数を見てみます。

```php
// 実際のクライアントコード
function 送金処理(送金銀行 $送金先銀行, int $送金額): void
{
    $送金結果 = $送金先銀行->送金(new 金額($送金額));

    if ($送金結果->成功したか()) {
        // 成功したときの処理
    } else {
        // 失敗したときの処理
        $送金パラメタ->通知()->通知する($送金結果->失敗理由());
    }
}
```

先程まで処理中に判断をして生成していた銀行クラスを、引数として受け取るようになっています。
こうする事により、使用したい銀行クラスが増えたとしてもこの関数を直接修正する必要がなくなりました。
増やしたとしても、引数として渡してくれればそのまま使用できるからです。
これなら、OCPの原則を満たせそうです

:::info
ちなみにこの『使いたい物(オブジェクト)を(内部で生成せずに)外から渡してあげる事』を
DI (Dependency Injection) と言います。
日本語では『依存性の注入』と訳される事が多いです。

内部で生成する = そのクラスのオブジェクトに直接依存している 状態となってしまいます。
外から渡す事により、この直接の依存関係がなくなり、(依存性が)注入された事になります

詳しくはこちらの記事でまとめていますので参考にどうぞ
[Qiita 初学者でも5分で理解できるようにDI(Dependency Injection)を説明してみた](https://qiita.com/hirodragon/items/73442390d551fe7376ea)
:::


ただ、DIを使用する事により、OCPを満たす事はできるようになりましたが、まだ不安があります。
というのも送金処理内では受け取った銀行クラスを

`$送金先銀行->送金(new 金額($送金額));`

という風に利用しているので、渡されて来たオブジェクトが `金額オブジェクト`を引数として取る `送金メソッド`を持っている前提となっています。

そこで、
```php
interface 送金先銀行
{
    public function 送金(金額 $金額): 送金結果;
}

```

と、送金銀行クラスが共通で持っているべきメソッドを `interface` として抽出し、引数の型として宣言しています。
その上で、各送金銀行クラスはその`interface`を`implements`して作成する事により、この送金処理関数に渡されて来る銀行オブジェクトは`金額オブジェクト`を引数として取る `送金メソッド`を持っている事を保証してあげているのです。

![](https://i.imgur.com/q1mSrjc.png)


この事を踏まえてもう一度、上記のコードを読んでみてください。
大きな修正は加えていませんが、柔軟に対処できるコードになった事が読み取れるかと思います。

:::info

ちなみにこの『送金銀行というモデルが必ず共通してもつべき振る舞いを抜き出している』

というのは、送金銀行モデルを**抽象化**したと言います。
※抽象化とは物事の必要な不必要な情報を削ぎ落とし、必要最小限にまとめる技法です

オブジェクト指向の各原則やパターンはほぼ、この**抽象化**という考え方により実現されています。
言い換えれば、オブジェクト指向とは**抽象化をする事により柔軟かつ堅牢な設計のシステムを作成する為の技法**である、と言っても良いでしょう。

:::

話は戻って、この送金処理はOCPの説明としては十分になったのですが、実はまだまだ修正の余地があります。

例えば、

```php
$送金結果 = $送金先銀行->送金(new 金額($送金額));
```

ここで使用している金額クラスも内部で生成しています = 依存関係にあります。

また、モデルという考え方からすると、もしかしたらこの金額や送金先というのは一つの概念として表した方が良いかもしれません。

この辺はこの先に説明する各原則やパターンも含む話となるので追って詳しく説明したいと思いますので詳細は省略しますが、例として下記のように作り変える事ができます。

```php
<?php
final class 金額
{
    private $金額;
    
    public function __construct(int $金額)
    {
        $this->金額 = $金額;
    }
}

interface 送金結果
{
    public function 成功したか(): bool;
    public function 失敗理由(): 失敗理由;
}

interface 送金先銀行
{
    public function 送金(金額 $金額): 送金結果;
}

final class みずほ銀行 implements 送金先銀行
{
    public function 送金(金額 $金額): 送金結果 
    {
        // 具体的な送金処理
    }
}

final class 送金先銀行取得
{
    public static function 取得(string $銀行名): 送金先銀行
    {
        if ($銀行名 === 'みずほ') {
            return new みずほ銀行();
        }
    }
}

function 送金処理(送金銀行 $送金先銀行, 送金パラメタ $送金パラメタ): void
{
    $送金結果 = $送金先銀行->送金($送金パラメタ->金額());

    if ($送金結果->成功したか()) {
        // 成功したときの処理
    } else {
        // 失敗したときの処理
        $送金パラメタ->通知()->通知する($送金結果->失敗理由());
    }
}

// 実際のクライアントコード
// このパラメタは実際はコントローラとか、バッチとかで作られるだろうね。
$送金パラメタ = new 送金パラメタ(100, new Eメールで通知()); 

送金処理(送金先銀行取得::取得($送金先銀行パラメタ), $送金パラメタ);
```

以上が、第一回オブジェクト指向を1から勉強しよう会の内容となります。

- なぜオブジェクト指向を使うのか
- 保守性・拡張性の高いソフトウェアとは？
- Open/closed principle(開放・閉鎖原則)
- Dependency Injection(依存性注入)

について説明しました。

次章は SOLID原則の一つ **Dependency inversion principle(依存性逆転の原則)** についての説明をしながら、さらにオブジェクト指向の理解を深めて行きたいと思います。

### Ⅱ. 依存関係をコントロールする

**Dependency inversion principle**

#### 概要を知ろう


続いて、SOLIDの『D』Dependency inversion principle(依存性逆転の原則) についての説明をしたいと思います。

まずはどういう原則かを見ていきましょう。


依存逆転の原則。
ソフトウェア開発において『依存』と言う言葉はよく耳にします。
言葉からするとその『依存』とやらを逆転するんだなーくらいしかわかりません。

逆転というと、『上下逆転』、『逆転ホームラン』といった使い方をしますよね。
つまり、前提として対象となる`2つの何か`(上の例で言えば、上と下、自チームと相手チーム)が存在し、その関係性が反転する時に使用する言葉でしょう。

この『依存性逆転』も逆転というからには`2つの何か`が存在していそうです。
そしてその2つの何かに存在する依存が逆転する原則なのだろうなという事が伺えます。

まずはそこから考えてみましょう。

##### 飲食店を開きます

飲食店を開こうと思います。
目的としては、料理を提供する事によりお客様から代金を頂き収益を上げたいと思っています。
当たり前に感じるかもしれませんがこの飲食店はそれが目的です。


この場合、内装や料理の種類、食器等はあくまで主目的を達成する為のサブ要素と言えます。

ここではホールと厨房に注目してみましょう。
極端な言い方となりますが、先の前提を踏まえると厨房から来る料理はあくまでサブ要素となります。

料理を作る事が目的ではなく収益を上げる事が目的となります。

つまり、ホールにて料理をお金に変える事が最重要となり、厨房で料理を作る事は重要度は低いと言えます。

こうして同じ店内の中で
- お金を生むコアな層。ビジネスの中心(ホール)
- コアな層をサポートする層(厨房)

と２つの層に分けて考える事ができそうです。
`2つの何か`が出てきました。

この`2つの何か`を中心にもう少し見ていきましょう。

##### いよいよオープン

この2つの層からなるこのお店ですが、まずは厨房にシェフAを雇ってみました。このシェフはカツ丼を作るみたいです。シェフが作るカツ丼をホールで提供して収益を上げましょう。ホールにカツ丼用の丼を用意し、メニューを作ってさっそくオープンです。

最初のうちは順調に売上も上がっていい感じでした。メインの目的の『収益をあげる』が実現できています。
ところが、不幸な事にシェフAがぎっくり腰になって入院を余儀なくされてしましました！大ピンチです。
しかたないので厨房にシェフBを雇う事にしました。
このシェフはざるそばを作るようです。
先程買った丼は使えなくなりましたが仕方ありません。ホールにザルとつゆ入れを買ってメニューを一新して営業再開です！

シェフBを雇った後も、シェフAがいた頃よりは少し落ちましたがざるそばも売れてくれています。カツ丼程ではないですが、『収益をあげる』がなんとか実現できています。

ところが・・・。
シェフBが突然海外で勝負したいと退職してしましました。しかたないので今度は厨房にシェフCを雇うことにしました。
このシェフはカレーを作るみたいです。
ザルとつゆ入れは使えなくなりましたがカレー皿を買ってきてサイドメニューを入れ替えて、、、


ここでオーナーふと思いました。
達成したいメインの目的は収益を上げる事なのに、サブ要素である厨房のシェフが変わる度に、ホールの食器やらメニューを変更しています。
カツ丼時代は凄く繁盛していたのにざるそばになって収益も下がり、今度はカレーを売ることになったけどちゃんと収益はあがるのだろうか。。と。

この2つの層(ホール、厨房)は、厨房で変更がある度に、ホールで提供する料理等の変更が必要な状態となっています。

この状態は、**ホール層が厨房層に依存している**と言えます。
なぜならば、**厨房層の変更がホール層に影響を及ぼしている**からです。


あくまでこのお店の目的はホールでお金を頂き、収益を上げる事です。
あのままカツ丼を売っていれば安定して収益があがっていたかもしれないのに、雇ったシェフがその都度作る料理を決めている為、ホールで提供する料理が変わってしまっていメインの目的に影響がでてしましました。

どうすれば良いのでしょう。

##### ここでひらめくのがオーナーの才能！

ホールにてオーナーが料理の種類を決める事にしました。
もちろんカツ丼です。
具体的に料理を作るのはシェフですが、何を作ってもらうかはホール側が決めました。『カツ丼を提供する』という契約を満たせるシェフだけを雇い、実際の調理はシェフにしてもらいましょう。

するとどうでしょう。
その後シェフD～シェフZまで様々なシェフに交代して行きましたが、ホール側には一切影響がでません。
それもそのはずです。ホールではカツ丼を売る準備がしてあり、各シェフ達とは『カツ丼を提供する』という契約を結んでいます。もうざるそばもカレーもホールには来ません。


つまり、ホール側はシェフがいくら変わろうとも何も変更する事なくひたすらカツ丼を売り続けていれば良いのです。
シェフの種類を気にする必要はなく、ただ一点『カツ丼を提供する』という契約が満たせているかだけがこの2層間での関心事となりました。


依存関係はどうなったでしょう。
先程までは厨房の変更がホールに影響してましたが、今は違います。
厨房の変更はホールに一切影響を与えていません。逆にホールで決めたメニュー内容がもし変わったら、厨房のシェフを変える必要があるでしょう。

つまり**厨房層がホール層に依存している**状態になりました。
最初とは真逆の状態になっています。

そう、**依存関係が逆転している**のです！



#### そろそろプログラミングの話しに戻ります

依存関係が逆転する例をプログラミングを離れて説明してみました。

ではこの例をプログラミングに置き換えて見ましょう。

2つのホールレイヤーと厨房レイヤーというものが存在していました。
そしてメインの目的を果たすホールレイヤーが上位レイヤー、厨房レイヤーが下位と言えます。

そして、下位レイヤーをそのまま使用していた際は依存関係が 上位 → 下位の方向に存在してしまっていました。

ですが、上位の作った(カツ丼を提供する)という契約に従った下位を作成する事により、依存関係が逆転したのです。
カツ丼を提供するという振る舞いを持っている事を下位レイヤーに保証させたのです。

そうです。プログラミング的に言うとこれはまさに `interface` の振る舞いでしょう。
もう少しプログラミングぽっく言い換えると

**シェフインターフェースには、「cookメソッドの返り値がカツ丼クラス」という定義がされており、そしてそのシェフインターフェースを実装したシェフクラス達を入れ替えながら経営する事により依存関係を逆転させた**

と言えます。

もう少しわかりやすくクラス図で依存関係の逆転前と逆転後を示してみます。


**依存関係逆転前**

![](https://i.imgur.com/OkvNNIV.png)
依存関係逆転前は、ホールは厨房層のシェフAクラスやシェフBクラスに依存しています。
このシェフAクラスとは実際に実装があるクラスなので、具象クラスという呼び方をします。
つまり、ホールは厨房層の具象クラスに依存している状態です。

**依存関係逆転後**
![](https://i.imgur.com/KOY3NzD.png)
それに対して依存関係逆転後は、ホールはホール層で定義した抽象(interface)に依存してるだけです。
それによりホールは厨房の具象クラス達の変更を知る必要がなくなりました。
逆に厨房層の具象クラスはホール層の抽象が変更される事があれば影響を受けるでしょう。

ホール層が厨房層とのやりとりをする際に必要な情報を抽象化した事により、この二層間の関心事は抽象のみとなりました。



最後に具体的上記を具体的なソースコードに落としてみたいと思います。


依存関係逆転前
```php
<?php
namespace 厨房  // 下位レイヤー

class シェフA
{
    public function カツ丼を作る(): カツ丼
    {
    
    }
}

namespace ホール    // 上位レイヤー

class ホール
{
    private $シェフ;
    
    public function __construct(シェフA $シェフA)
    {
        $this->シェフ = $シェフA;
    }

    public function 料理を提供する(): カツ丼
    {
        return $this->シェフ->カツ丼を作る();
    }
}

// 料理のクラスは割愛。

// クライアントコード
$シェフ = new 厨房\シェフA();
$ホール = new ホール\ホール($シェフ)
$ホール->料理を提供する(); // シェフAが作ったカツ丼が提供される

// シェフがAからBに交代
class シェフB
{
    public function ざるそばを作る(): ざるそば
    {
    
    }
}

// シェフの変更に合わせて上位レイヤーのホールも修正が必要となる
class ホール
{
    private $シェフ;
    
    public function __construct(シェフB $シェフB) //シェフBに修正
    {
        $this->シェフ = $シェフB;
    }

    public function 料理を提供する(): ざるそば
    {
        return $this->シェフ->ざるそばを作る();    // シェフBに合わせて修正
    }
}

$シェフ = new 厨房\シェフB();
$ホール = new ホール\ホール($シェフ)
$ホール->料理を提供する(); // シェフBが作ったざるそばが提供される

// 下位レイヤーが変更される度、上位レイヤーの修正が必要となっている
```

依存関係逆転後

```php
<?php
namespace ホール

Interface シェフ    // 上位レイヤーでinterfaceを定義
{
    public function 調理する(): カツ丼
    {
    
    }
}

class ホール
{
    private $シェフ;
    
    public function __construct(シェフ $シェフ)    // 定義したinterface に依存した形で型宣言
    {
        $this->シェフ = $シェフ;
    }

    public function 料理を提供する(): カツ丼
    {
        return $this->シェフ->調理する();
    }
}

namespace 厨房  // 下位レイヤー

// 上位レヤーにて定められた interface のっとって作成する
class シェフA implements ホール\シェフ
{
    public function 調理する(): カツ丼
    {
        // シェフAなりのカツ丼を作る処理
    }
}

class シェフB implements ホール\シェフ
{
    public function 調理する(): カツ丼
    {
        // シェフBなりのカツ丼を作る処理
    }
}

// クライアントコード
$シェフ = new 厨房\シェフA();
$ホール = new ホール\ホール($シェフ)
$ホール->料理を提供する(); // シェフAの作ったカツ丼が提供される

// 依存関係が逆転しているので、シェフBに変更してもホールは影響を受けない
$シェフ = new 厨房\シェフB();
$ホール = new ホール\ホール($シェフ)
$ホール->料理を提供する(); // シェフBの作ったカツ丼が提供される
```

このように上位レイヤーにて抽象化を行い、下位レイヤーがそれに従う事により、依存の方向を逆転する事ができます。
依存関係の方向が制御出来た事により、本来守られるべきコア部分の変更をせずにシェフの変更ができるようになりました。

そして、勘の良い方はもうお気づきだと思いますが、先程OCPを説明した際もこの依存逆転は使用されています。
OCPを実現する為には依存方向をコントロールする事はとても重要な考え方となります。
上位概念から下位概念への依存を発生させない事が出来てはじめて、上位概念を変更しなくてはいけないリスクからから遠ざける事ができ、変更容易性を担保する事ができるのです。

なぜなら上位概念はシステムの根幹となるため、変更される可能性が低い層だからです！
変更される可能性が高い下位概念（画面UIや、DBなど永続化など)が変更されたとしても、保護されるげき存在だからです。

#### DIPまとめ


最後にもう一つ、より普段目にしやすい例のサンプルコードを記載します

コアとなる層(コアドメイン)からするとサブ要素とも言えるデータの保存先をDIPを使って依存方向を逆転させる事によりコアドメインのソースを修正する事なく切り替えられるようになっています。
開発途中はin memory にデータを保存し、開発が進んだ段階でデータベースに保存するように差し替えられるようになっています。


```php
<?php

class UserRegistrationController extends Controller
{
    /**
     * UserDB
     */
    private $db;
    
    public function __construct(UserDB $db)
    {
        $this->db = $db;
    }
    
    public function register(string $name, string $password): void
    {
        $this->db->create(new User($name, $password));
    }
}

interface UserDB
{
    public function create(User $user): void;
}

#-------- ↑ 上位

#-------- ↓ 下位

final class InMemoryDB implements UserDB
{
    private $users = [];
    
    public function create(User $user): void
    {
        $this->users[] = $user;
    }
}

final class MySqlDB implements UserDB
{
    public function create(User $user): void
    {
        $mysql = new MySQL();
        $mysql->insert('インサート文');
    }
}

final class めっちゃ高いOracleDB implements UserDB
{
    public function create(User $user): void
    {
        $oci = new OracleOci();
        $oci->insert('インサート文');
    }
}
```


こうして上位概念が下位概念に依存している際はDIPを使用して依存関係を逆転される事により、より大切な上位概念を守る事ができます。

上位概念が下位概念に依存しない関係を構築した上で、DIにより適切に依存を注入していく事ができるようになります。



### Ⅲ. 役割を適切に分割する

**Single Responsibility Principle**

次に紹介するのはSOLIDの『S』Single Responsibility Principle(単一責任の原則)です。

最初に少し言い訳をさせてください。
本稿では基本的に概念理解から入り、具体的な例を紹介して理解して頂くスタイルをとっていますが、この章はどちらかというと一般論が中心の説明となります。

と言いますのも、この概念の言語化をずっと試みてはいますが、正直まだ納得のいくレベルでの言語化ができていません。頭の中ではある程度感覚で理解出来ているのですが、この『感覚』の部分を初学者向けに噛み砕いて説明をしたいと思っていますが、まだ適切な表現を見つけ出せていないです。


言い訳はこの辺にしてさっそく読み解いて行きましょう。

#### 概要をみてみよう

「単一責任の原則」
名前だけだと全く具体的なイメージがわきませんね。
責任ってのを一つにすれば良いんだなーくらいの事はわかりますが。


*プログラマが知るべき97*、やその他の書籍では概ね、
『クラスや関数を変更する理由は一つであるべきだ』という風に説明されています。
言い換えれば、**何かの処理を変更する理由が2つ以上あってはいけない**。
という意味となります。

では、なぜ2つ以上あってはいけないのでしょうか？
また、一つとはどの程度の単位なのでしょうか？
文字通り受け取ると、全てのクラスは一つの機能を持った関数を一つだけ持っているように受け取れます。膨大なクラスを作成する必要がありそうです。

もちろんそんな事を目指すべきだと示している原則ではありません。


ここでまた筆者の大好きな *Clean Architecture* の言葉を借りたいと思います。


> ソフトウェアシステムに手を加えるのは、ユーザーやステークホルダーを満足させるためだ。
この「ユーザーやステークホルダー」こそが、単一責任の原則(SRP)が指す「変更する理由」である。

と記されています。
少しイメージが湧いてきました。


この本では「ユーザーやステークホルダー」の事をアクターと表現し最終的には

> モジュールはたった一つのアクターに対して責務をおうべきである。

とまとめています。

良書の表現を借りる事によってだいぶイメージが具体化してきたので、そろそろプログラミングを離れて概念理解から入ってみたいと思います。

#### そろそろ概念理解もあった方がわかりやすいよね

##### 仲良しの隣人

Aさんは隣のBさんと仲良しです。
Aさんは日勤者、Bさんは夜勤者なのですが、最近効率よく車を所有する方法を思いつきました。

『カーシェアをするのです！』

幸い勤務時間帯は完全にずれているので、昼間はAさんが通勤で使い、返ってきた車に乗ってBさんも通勤します。
休日はお互い事前に話して使用者を決める事にしました。
(ホントに仲良しですね！)

##### スキーに行きます
しばらくはそれで何の問題もなく回っていたのですが、とある連休にAさんスキーに行くことになりました。

「そうだ、車の屋根にルーフキャリアをつけよう」

Aさんは車の屋根にルーフキャリアをつけてスキーへ出かけました。

##### そして翌週
そして連休明けの平日の夜。
AさんにBさんから電話が入ります

「勝手に車の状態を変更しないでほしかったよぅ」

もちろん仲良しなので怒ってはいませんが、困ってそうです。
詳しく話しを聞いてみると、今まで聞いたことはなかったのですが、Bさんは出勤した後この車を屋内の立体駐車場に止めているらしいのです。
そして、先日Aさんが付けたルーフキャリアを付けた事により、高さ制限にひっかかってしまったらしいのです。。。
おかげで慌てて近くのコインパーキングを探して駐車したらしいのですが、危うく遅刻する所だったと。
Aさんも申し訳なくてあやまりっぱなしです。

##### なんでこうなった？
なぜこうなったのでしょうか。
これはAさん、Bさん。それぞれ同じ車を使用していた為、Aさんの理由でもBさんの理由でもこの車を修正しなくてはいけない状態だった事による悲劇と言えます！
AさんとBさんは同じ車を使用していながらも、それぞれが同じ環境で使用していた訳でもないので、詳細の使用方法や変更理由まで把握していないからです。
つまり、この車には変更理由が二つ存在していた事になります。
では、どうすれば良かったのでしょう？

答えは簡単です。
AさんとBさんそれぞれの車を持っていれば良かったのです。
(コストはかかりますけどね)

そうすれば、Aさんがルーフキャリアをつけようが、Bさんがウーハーを変えようがお互いの車に影響はありません。
当たり前ですね！



ここでプログラミングの話しに戻しますと、お気づきかとは思いますが、
AさんBさんがアクター、車がクラス、という事になります。
クラス(車)を修正する理由(アクター)が2つ存在していたのです。
つまり二人は単一責任の原則に反していたのですね。

このように、一つのクラスが複数の目的の為に存在していると、修正が発生した時の影響範囲が大きくなります。影響範囲が広がるという事は既にテスト済の処理の再テストが必要となるという事です。

#### もう少しコードよりに説明してみます

次にソースを使って別の例を見てみましょう。
先ほど使用したような送金システムを例にとってみます。


```php
<?php

final class 送金管理
{
    private $銀行間転送API;
    
    public function __construct()
    {
        $this->銀行間転送API = new 銀行間転送API();
    }
    
    public function 送金する(int $金額): void
    {
        if ($金額 > 100000) {
            throw new RuntimeException('送金金額が10万円を越えています');
        }
        
        $this->銀行間転送API->送信処理($金額);
    }
}
// クライアントコード
$送金管理 = new 送金管理();
$送金管理->送金(50000);
```

パッと見はまた問題なさそうです。
しかし、この処理は二つの責任が混在しています。
- 送金する際には最大金額をチェックした後ではないといけないという順番を担保する処理
- 送金金額が最大値を越えているかのチェック処理

送金の際のルールを決めているのは経営本部
最大送金金額を決めているのは営業部
だとします。つまりアクターが2人いる状態です。


そうすると、営業部が「今月は送金最大金額を2倍にするキャンペーンをうつぞ！」的に最大金額を10万円から20万円に変更したい時もこのクラスの修正が必要が必要となります。
(かなり謎なキャンペーンではありますが)
また、経営本部が、そもそも最大金額をチェックしなくてはいけないというルール自体を変更する時もこのクラスの修正が必要です。

単一責任の原則を意識してリファクタリングをしてみようと思います。

```php
<?php

interface 最大送金金額確認
{
    public function 最大金額を超過しているか(int $金額): 最大送金金額確認結果;
}

interface 最大送金金額確認結果
{
    public function 失敗したか(): bool;
    public function 失敗理由(): string;
}

final class 一般会員最大送金金額確認 implements 最大送金金額確認
{
    public function 最大金額を超過しているか(int $金額): 最大送金金額確認結果
    {
        if ($金額 > 100000) {
            return new 最大送金金額確認結果(false, '最大金額オーバー');
        }
        return new 最大送金金額確認結果(true);
    }
}

final class 送金管理
{
    /**
     * @var 銀行間転送API
     */
    private $銀行間転送API;
    
    /**
     * @var 最大送金金額確認
     */
    private $最大送金金額確認;
    
    public function __construct(最大送金金額確認 $最大送金金額確認)
    {
        $this->銀行間転送API = new 銀行間転送API();
        $this->最大送金金額確認 = $最大送金金額確認;
    }
    
    public function 送金する(int $金額): 送金結果
    {
        $最大送金金額確認結果 = $this->最大送金金額確認->最大金額を超過しているか($金額)
        
        if ($最大送金金額確認結果->失敗したか()) {
            return new 送金失敗結果($最大送金金額確認結果->失敗理由());
        }
        
        return $this->銀行間転送API->送信処理($金額); // この銀行間転送API::送信 は送金結果を返却してくれるメソッド
    }
}

// クライアントコード
$金額確認 = new 一般会員最大送金金額確認();  // 実際にはもう少し別の方法で生成されるとおもうけどね
$送金管理 = new 送金管理($金額確認);
$送金管理->送金(50000);
```

元あったクラスはは送金の際のルールを保障する事のみにし、
実際の最大送金金額のチェック処理は別のクラスへ移譲し、DIにて動的に受け取る事にしました。
※ ちなみに実際の『送金』という処理だけは最初から別クラス(銀行間転送API)に処理移譲してあったのですね。惜しい！

この事により、『送金ルール』、『最大送金金額』はそれぞれ別のクラスとなり、修正する際もそれぞれのクラスを修正するだけでよくなります。
単一責任の原則を満たした事により、OCPの原則も満たせるようになってますね。



#### SRPのまとめ

変更容易性を実現する為には、この『単一責任の原則』はとても重要な考え方となります。
ただし、この原則は一番受け手により理解の仕方が統一されずらい原則でもあります。

個人的にですが、その理由は『責任』というのが抽象的な言葉だからだと思います。
この責任を的確に線引きし境界つけるには、やはり経験や慣れが必要となってきます。
ですが、まとめがそれではちょっとげんなりしてしまうので、最後に全く別の表現を紹介しようと思います。

ここまでの説明と合わせて何か一つでも責任境界を判断するヒントになるかもしれません。

『よい抽象には良い名前がつく』 **A good abstraction has a good name.**

責任境界を引く際の基準をベースにした言葉ではなく、責任境界を引いてみた後の判断基準となる指針です。
クラスとなる候補の概念からまずは適切な名前を付けてみるのです。

適切な名前を持ったクラスには、おそらくその名前で表現できる範囲での処理が入る事となるかと思います。
そして、これはメソッドにも言えると思います。
より良い名詞がクラス名だとしたら、より良い動詞がメソッド名です。

それらを踏まえて筆者なりに表現するとしたら、
『メソッドは名前で表現できる以上の処理を持つべきではない』
でしょうか。

適切な名前つけが出来れば、そこに存在すべき処理はあきらかです。
そう、その名前で表現されている処理のみを保持すれば良いのです。
もし、今作成したクラスやメソッドに、名前で表現できる以上の処理が記載されていましたら、外にだして新たな適切な名前を付けてあげましょう。

そうすれば自然と単一責任の原則を満たしているかもしれません。

先ほどの例で言いますと、リファクタリング前は 『送金する』メソッド の中に、最大金額判定のロジックが記載されていました。
これは『送金する』という振る舞いではあらわされる動作ではないですよね。
つまり、『最大金額を超過しているか』という別メソッドに処理を移譲する事が容易に思い浮かびます。
そして、その際同じクラス内に『最大金額を超過しているか』メソッドをprivateメソッドとして生やす事もできますが、
このメソッドはアクターが違うので、別のクラスにあるべきだという結論に達しました。
そこで別のクラスとして切り出しDIしてあげる事により処理移譲させたのです。

SRPは手法、概念、共に理解した上で適切な切り出しをする事により最大の効果を発揮しますので、
『処理』だけではなく、『ソフトウェアが解決したい問題』や、『それを扱うユーザーの観点』、そして『適切な名前』などを総合的に鑑みてより良い形を模索する事が重要だと言えると思います。



### ⅳ. 過度な契約は柔軟性を損ねる
**Interface segregation principle(インターフェース分離原則)**

ここまでOCP, DIP, SRPと3つの原則を見てきました。

この原則を紹介している中で常に中心的な役割を担っていたものがあるかと思います

そう、『インターフェース』 です。
OCPという概念を実現するにはDIPにより、依存関係をコントロールし、SRPにより、責任を適切に分離してく必要がありました。
そして、その際に必ずと言っていいほど、『インターフェース』 による抽象化が行われていたかと思います。

次に紹介するのは、そのインターフェースの指針とするべ原則です。
もう少し具体的に言うと、インターフェースの大きさに関する原則です。

#### 概要をみてみよう

少しここで『インターフェース』を振り返ってみましょう。

インターフェースは『使用する側』と、『実装する側』の間に取り交わした約束事のような物です。

インターフェスを使用して抽象化を行うことにより、そのものが持つ特徴の中から不要な物を削ぎ落とし、使う側、実装する側間での『関心事』となるものだけを切り出しているからです。

別の表現をすると、その2者間(使う側、実装する側)において、気にする必要のある**唯一の関心事**がインターフェースです。
そこで抽象化された事以外にお互い関心を持つ事はありません。


使用する側は、インターフェースにて定義された関数シグネチャが定義されているかのみを関心事とし、その具体的な実現方法は一切知る必要はありません。
また、実装する側においても、インターフェースにて定義された関数シグネチャを定義できているかのみを関心事とし、使う側での具体的な使用方法を一切しる必要はありません。
くどいようですが、2者間で必要な契約事のみに抽象化されており、残りは捨象(抽象の逆)されているからです。


それを踏まえて、ここまでの解説ではインターフェースの事を『契約』や『約束事』と表現してきました。
『抽象化』という意味合いからは正確には異なるのですが、必要な関心事のみが抽出されている = その関心事が必ず約束されている、と言えるからです。


本題のISPが定義している原則の話しに戻ります。

**インターフェース分離原則**

これはインターフェースの粒度について定義しています。

簡単に言い換えると、
『インターフェースは適切な単位で分離しておいた方が良いよ』
と言う原則です。


もちろんこれまで同様に、必ず原則には理由があります。
言い方を変えると、原則を意識して設計をしないと生じる不都合があります。

その理由とは、インターフェースが2者間での契約である以上、余りにも厳しい契約が結ばれていると自由度が下がるからです。
これだけだとわかり辛いですね。
ここは今までどおりいったんプログラミングを離れて概念理解から入ってみたいと思います。

#### 編集くんと作家さん

編集担当者がいたとします。名前を『編集くん』とでもしておきましょう。
この編集くんは常に忙しいので手帳にスケジュールをびっしり書き記しています。
多忙でも効率よく予定をこなせるように、色を3色切り替える事ができるペンでジャンルに応じて色分けをして管理するようにしています。
色分けは凄く大事な機能です。そうしないと、とてもじゃないと業務が回りません。


この編集くんの会社は行き届いた会社なので、このペン会社から支給して貰えます。
総務部に届け出をしておけば必要に応じていつでも支給してくれるのです。


そこで編集くんは総務部に届け出をしておきました。
編集くんは間違いの無いように、総務部には以下のように伝えています。
ここで必要としている物は『書くことが出来てボタンで3色を変えられるペン』物です、と。(いわゆる3色ペンですね)
なので、くださいと言ったら自動的に『書くことが出来てボタンで3色を変えられる』ペンが貰えます。


そんなある日この編集くんには担当作家さんができました。
この作家Aさんはアナログ至上主義の為、作品は全てノートに手書きで書いています。
編集くんはなんとか作家Aさんが効率よく作品を仕上げてもらう為に、いつもペンを用意してあげる事にしました。
この作家Aさん、手書き派の代わりといってはなんですが書くためのペンにこだわりは一切ありません。（弘法筆を選ばずってやつですね！）
作家Aさんのペンがそろそろインクが切れそうだと察した編集くんはさっそく総務部に「ペンをください」と伝えました。
編集くんと総務部の間に交わした支給物に関する約束事はご存知の通り『書くことが出来てボタンで3色を変えられる』ペンという事です。
ですので当然、総務部の人はそれを満たすペンを用意して編集くんに渡し、それを作家Aさんに渡しました。
作家Aさんにとっては書くことさえできれば良いのですが、特に3色機能があっても困る訳ではないので特に問題ありません。

編集くん、作家Aさん、特に困ってないので問題なさそうです。

**そんな折に監査が入りました**

ところが。。
総務部の方はそうではありませんでした。
監査が入った際に、毎月の経費を見られて指摘を受けたのです。

「この期間に20本ペンを買っているけど、この経費は少し無駄があるのではないですか？」
監査役の人も業務はちゃんと理解しています。
必要とする物に必要な経費をかける事に大して文句なんて言ったりしません。
そして、実際このペンは20本必要だったのです。編集くんが自分用として10本、作家A用として10本、インクがなくなるまでちゃんと使用しており、それも総務帳簿に記されています。

ではなぜこの監査役の人は懸念を抱いているのでしょうか？
それはペンの単価にあったのです。

実は総務部で仕入れることのできるペンはいくつか種類あります。
単純に『書くことのできるペン(色は黒しかでません)』や、『書くことが出来て、ボタンで3色変えられるペン』です。
そしてこの2つは値段が3倍程違います。

監査役の人が言うには、
「編集くんは確かに色分けする必要があるから、高い方でも仕方ないけど、作家Aさんは書けさえすれば色を切り替える必要はないんだよね？」
「なら、この20本のうち10本は安い方のペンで良かったのでは？」と。

確かにその通りです。
総務部の方ももちろんその方が良いと思います。
では、なぜそうできなかったのでしょう？

それは、編集くんと総務部の間に、ペンとは『書くことが出来てボタンで3色を変えられる』という約束事がかわされていたからです。
つまり、安い方のペンではその約束事を満たせないので、常に高い方のペンを渡す必要があったのです。（名誉の為に伝えておきますが、総務部の方は有能な方です。ただ単に契約に厳密な正確だったのです。）

監査の人としては納得はいきませんが、その場はなんとか収まりました。


**編集くんメキメキ実力伸ばしてます**


しかし、さらにその後困った事になりました。
編集くんの業務範囲がさらに拡大して、とてもじゃないけど3色の表現では足りなくなったのです。
スケジュール帳を10色で細かくメモしなくては行けない程に！

そこで編集くんは総務部の方に、約束事を少し変更する旨を伝えました。
欲しい物はとは『書くことが出来てボタンで10色変えられる』ペンだと。
10色ペンは単色ペンの12倍の価格です。
でも大丈夫。この編集社は必要な物には惜しみなく投資してくれる凄く働きやすい会社だからです。


総務部との約束事を変更した事によって、編集くんの業務効率を落とさずにすみました。
これでバリバリ働けるぞ！と思っていた矢先、また監査が入ります。

その時の監査の人の反応が・・・

「さすがに今回ばかりは納得がいきません！」

なぜ監査の人は怒っているのでしょう。

当然皆様もう想像が容易につくかと思いますが、ペンにかかっている経費が跳ね上がっていたからです。
監査期間の間に総務部はまたペンを20本買っていました。

編集くんが自分で使うように10本、作家Aさんにわたす分として10本。
そして、前回と同じように編集くんと総務部の方の間には約束事があります。
必要なのは『書くことが出来てボタンで10色変えられる』ものだと言うことです。

なので、編集くんが使う時も、作家Aさんに渡す時も総務部の方は約束事に従って渡すしかないのです（本当に厳格な人ですね！）

ですので、元々3色も使わない作家Aさんに渡すペンも10色ペンに変更せざるを得なかったのです。

#### なぜこうなってしまったのでしょう

編集くんと総務部の方との間には１つの約束事しかなく、どんな場合でもその約束を満たすようなペンを渡していたからです。
この事によって、編集くんが必要としている内容が変わった際に、本来関係ないはずの作家さんい渡すペンまで変更を余儀なくされていたのです。

つまり、こうなってしまった原因は『約束事』が複数の条件を含んでいて適切にな大きさになっていなかったからです。

#### そろそろ本題に戻ります。

話をプログラミングに戻しましたいと思います。
とっくに皆さんお気づきだと思いますが、今回編集くんの話で出てきた中で、編集くんがと総務部の方が『クラス』となり、それぞれ『実装を提供する側』と『使用する側』の関係です。
そして、この2者間で結ばれた『約束事』こそが、今回のテーマ、『インターフェース』です。


そして、インターフェースにて抽象化されたペンの約束事が大きすぎたのです。
インターフェースが大きいことにより、作家さん用ペンクラスは本来不必要な色を3色変更するメソッドを理由に変更が生じてしまっています。

図で表してみましょう


![](https://i.imgur.com/7cBKaOE.png)

インターフェースに複数の約束事が一括りにされている為、総務から渡すペンは本来不必要な`作家さんに渡す()`に渡したいペンも、使用される事はないのに `色を3色変える()`を実装をする必要性が出てしまっています。
かなり不自然な形と言えます。


そして、その後インターフェースの修正が入ってしまいました。

![](https://i.imgur.com/tUkxbf3.png)


これにより、本来不必要なはずの作家さん用ペンクラスにまで修正が必要となってしまったのです。
本来必要としないものに依存してしまっている結果により生じた変更と言えるでしょう。
本来クラスは使用していないメソッドを持つインターフェスに依存するべきではありません。
そのような依存が発生すると今回のように、不必要な修正を余儀なくされるでしょう。

これまで良いソフトウェアを作成する為『変更容易性』が高い事を指針としてきました。
使用していないメソッドの為にクラスを変更しなくてはいけないようでは、とても変更容易性が高いとは言えません。


インターフェース分離原則(ISP)はまさにこのようなケースを回避する為の原則です。

インターフェースを適切に分離する事により、インターフェースの実装クラスが必要なメソッドのみに依存できるようにするべきなのです。

下の図はISPに従ってインターフェースを分割してみた状態です。


![](https://i.imgur.com/EzrqpZd.png)

インターフェースを適切に分割した事により、編集くん用のペンも、作家さん用のペンもそれぞれ必要なメソッドのみを抽象化されたインターフェースに依存する形となりました。、
こうする事により編集くんのペンが10色になろうが20色になろうが、今後作家さん用ペンクラスに修正を加える必要がなくなりました。


#### ISPまとめ

インターフェースは抽象化技法に欠かせない存在です。
ただ、適切な抽象化を行い、実装クラス(具象クラス)が使用していないメソッドに依存する必要がないように注意が必要です。
インターフェースは具象クラスに実装を強要します。
１つのインターフェースで複数のメソッドを強要しなくてはいけなくなっていたら、それは分割する必要性がないか検討してみる必要があります。

**不要なものには依存しない**


### ⅴ. 継承関係に警鐘を鳴らす
**Liskov substitution principle(リスコフの置換原則)**


SOLID原則の最後の一つとなるのがリスコフの置換原則(LSP)です。


まずはwikipediaの説明に目を通してみたいと思います。
> 型システムなどにおける型の派生に関する議論において、派生元の型（基底型）と派生先の型（派生型）の間に成り立っていなければならない規則性

なんとなく雰囲気はつかめますが少し難しいですね。
この原則は基底型と派生型の間に成り立つ関係性を示した原則です。

もちろん、今までの原則同様にその関係性を気にしなくてはいけない理由がそこには必ずあります。必要性のない原則は存在しません。

さっそく定義されている関係性と、その必要性を見ていきたいと思います。
今回の原則は概念理解よりも具体的な説明の方がわかりやすいと思いますので、具体的な例を元に解説します。


#### 派生型と規定型は置換可能でなくてはいけない

型システムにおける型とその派生形、とはなんでしょうか。
ぱっと思いつくのは『継承関係』だと思います。
つまり、親クラスを継承した子クラスがその規定型と派生型の関係だと言えます。

一般的にリスコフの置換原則は継承関係にあるクラス同士の原則という色合いが強いので、その観点で原則の内容を表現するとこの原則は

『子クラスが使用されている箇所は親クラスに置き換え可能でなくてはいけない』

と表現できます。

例えばクラスTの派生クラス(子クラス)Sがあった場合、S型のオブジェクトが使用されているところはT型のオブジェクトに置き換えても問題ないようにしなくてはいけない。

という事です。

言っている事は簡単なので意味はわかります。

ですが、これだけだと必要性がわかりません。
もう少し具体的に紐解いていきたいと思いましょう。

#### 逆のパターンで考えてみる
それでは逆にこの原則に違反している状態を考えてみましょう。
そこに不都合があればこの原則の必要性がわかるかもしれません。

つまり、親クラスと子クラスが入れ替え不可能な状態です。

例えば以下のようなクラス AppModel と UserModel が定義されていたとします。
```php
<?php
class AppModel
{
    public function save(Data $data): bool
    {
        // 処理
    }
}

class UserModel extends AppModel
{
}

function 更新する(AppModel $model, Data $data)
{
    if (!$model->save($data)) {
        throw new Exception('更新に失敗しました');
    }
}

// クライアントコード
更新する(new UserModel(new Data([1, 2, 3])));

```

UserModelはAppModelを継承していますが、特に何も実装が記述されていません。
この場合UserModelは実質AppModelと同じ処理しか持ち合わせていないので、クライアントコードをAppModelに変更しても(当たり前ですが)問題なく動くでしょう。

```php
<?php

// クライアントコード
更新する(new UserModel(), new Data([1, 2, 3]));
// ↓親クラスに変更
更新する(new AppModel(), new Data([1, 2, 3]));  // 問題なく動く
```
では、置換可能でない状態とはどのような状態でしょうか？
それは親クラスの処理を拡張した際に起こりえます。
先ほどの2つのクラスが例えば以下のようだったとしましょう。
```php
<?php
class AppModel
{
    public function save(Data $data): bool
    {
        // 処理
    }
}

class UserModel extends AppModel
{
    public function save(Data $data, UserType $userType): bool // UserTypeはinterface
    {
        // 処理
    }
}

function 更新する(AppModel $model, Data $data)
{
    if (!$model->save($data, new UserTypeAdmin())) {
        throw new Exception('更新に失敗しました');
    }
}

// クライアントコード
更新する(new UserModel(), new Data([1, 2, 3]));
```

UserModelが saveメソッドをオーバーライドしています。
その結果関数シグネチャが変更されており、2番目の引数として UserTypeの実装型を渡してあげる必要があります。

当然このような場合単純に基底クラスである AppModel に置き換える事はできません
```php
<?php

// AppModelを渡す
更新する(new AppModel(), new Data([1, 2, 3])); // error
// AppModelのsave()は UserType を引数に取れない為エラーとなる！
```

では、このような作りとなっている場合は以下のように更新する()をしてあげる必要があるでしょう。

```php
<?php

function 更新する(AppModel $model, Data $data)
{
    if ($model instanceof UserModel) {
        if (!$model->save($data), new UserTypeAdmin())) {
            throw new Exception('更新に失敗しました');
        }
    } else {
        if (!$model->save($data)) {
            throw new Exception('更新に失敗しました');
        }
    }
}

// クライアントコード
更新する(new UserModel(), new Data([1, 2, 3])); // どちらも動く
更新する(new AppModel(), new Data([1, 2, 3])); // どちらも動く
```

使用する際に、その型がどの派生型(子クラス)なのかを知らない限り、適切な処理を記述する事ができません。
しかもまた別の派生型を追加した場合はこうなるでしょう

```php
<?php

// AppModelの派生型を追加
class ItemModel extends AppModel
{
    public function save(Data $data, bool $addFlg): bool
    {
        // 処理
    }
}

function 更新する(AppModel $model, Data $data)
{
    if ($model instanceof UserModel) {
        if (!$model->save($data), new UserTypeAdmin())) {
            throw new Exception('更新に失敗しました');
        }
    } elseif ($model instanceof ItemModel) { // 追加したItemModel用のsave処理を追加
        if (!$model->save($data), true)) {
            throw new Exception('更新に失敗しました');
        }
    } else {
        if (!$model->save($data)) {
            throw new Exception('更新に失敗しました');
        }
    }
}

// クライアントコード
更新する(new ItemModel(), new Data([1, 2, 3]));
```

追加した派生クラスだけでなく、既存の更新処理にもその派生型であった場合の処理を追加する必要性があります。
既存の処理に修正を加えなくては追加できない？
どこかで聞いたことがありますね。
そうです、この処理は完全にOCPに違反しているのです。

#### 整理します

何が悪かったのか、少し整理してみます。
今回規定型と派生型の定義内容が変更されてしまっていました。
クラスは大まかに『実装を提供する為のクラス』と、それを『使用する為のクラス』があります。
今回の規定型や派生型は共に『実装を提供する為のクラス』です。
その提供している実装が、派生型毎に変化してしまっているのです。
そうなると『使用する為のクラス』は大変です。
型宣言により特定の型を受け取るように宣言していても、その中でさらに具体的に「どの派生クラスであるか」を認識しないと適切な処理を書くことができないからです。
この「どの派生クラスであるか」を認識する、という処理が存在する以上、かならず機能追加時に修正を加える必要が出てしまうでしょう。つまりOCPの原則に違反してしまい、著しく変更容易性をそこなってしまう結果となってしまいます。

多くの場合、LSPの原則に違反している場合、漏れなくOCPの原則にも違反してしまうのです。



